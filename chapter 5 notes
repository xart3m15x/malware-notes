\\IDA Pro
- IDA Pro stands for Interactive Disassembler Profressional
- Supports several file formats, including Portable Executable (PE), Common Object File Format (COFF), Executable and Linking Format (ELF), and a.out
- Can perform tasks such as function discovery, stack analysis, local variable indentification, and more
- Includes extensive code signatures within its FLIRT (Fast Library Identification and Recognition Technology)
  - Allows it to recognize and label a disassembled function
    - Especially library code added by a compiler
- Can be modified, manipulated, rearranged, or redefined to allow interactiveness
- Can add comments, label data, name functions, then save it to the IDA Pro Database (IDB) to work on later
- Also supports plug-ins

  Loading an Executable
- Unless you are performing malware analysis on cell phone malware, probably won't need to change processor type
  - Cell phone malware is created on several different platforms)
- Can disassemble the file as a raw binary
  - Sometimes malware appends shellcode, additional data, encryption parameters, or even additional executables to legit PE files
  - Won't load this into memory when malware is run by Windows or IDA Pro
- Rebasing: An operation that is performed when a Windows loader can't load a file at its preferred address (because the address is already taken)
  - Most common with DLLs since they are often loaded at locations that differ from their preferred address
  - If this happens, check the Manual Load checkbox and specify the new virtual base address
- IDA Pro doesn't include the PE header or the resource sections in disassembly
  - These are places that malware often hides malicious code
  - When doing manual load, will ask if you want to load each section, one by one

IDA Pro Interface
- Can display disassembly window in graph or text, and switch by pressing spacebar
- Use Auto comments checkbox if still learning assembly, will be useful

Graph Mode
- Typically excludes certain information, such as line numbers and opcodes
  - To show opcodes, set Number of Opcode Bytes to 6
- Colors of lines and direction help show the program's flow
  - Red if a conditional jump is not taken
  - Green if the jump is taken
  - Blue if it's an unconditional jump
  - Upward arrows denote a loop situation

Text Mode
- More traditional view
- Need to use it to view data regions of a binary
- Displays the memory address and section name where the opcodes will reside in memory
- Arrow window shows the program's nonlinear flow
  - Solid lines mark unconditional jumps
  - Dashed lines mark conditional jumps
  - Arrows facing up indicate a loop

Useful Windows for Analysis
- Function window
  - Lists all functions in the executable and shows the length of each function
  - Filter for large, complicated functions since they are likely to be interesting
  - Associates flags with each function (F, L, S, etc.)
    - Most interesting is L which indicates library functions
- Names window
  - Lists every address with a name, including functions, named code, named data, and strings
- Strings window
  - Shows all strings
  - Shows only ASCII strings longer than 5 characters, can be changed in setup
- Imports window
  - Lists all imports for a file
- Exports window
  - Lists all exported functions for a file
  - Useful for DLLs
- Structures window
  - Lists the layout of all active data structures
  - Also allows to create your own data structures to use as memory layout templates
- Offers a cross-reference feature for interesting code

Returning to the Default View
- Return to default view Windows -> Reset Desktop
  - Won't undo any notes or disassembly
  - Save Desktop saves the modifications

Using Links and Cross-References
- Sub links -> links to the start of functions such as printf or sub_0410A0
- Loc links -> links to jump destinations such as loc_40107E
- Offset links are links to an offset in memory

Navigation Band
- Color-coded linear view of the loaded binary's address space
  - Light blue is library code as recognized by FLIRT
  - Red is compiler-generated code
  - Dark blue is user-written code
- Dark blue region is probably the place you want to look
- Sometimes FLIRT isn't perfect, sometimes it won't recognize and label all library code properly
- IDA Pro's default colors for data:
  - Pink for imports
  - Grey for defined data
  - Brown for undefined data

Jump to Location
- Jump to a raw file offset, choose Jump -> Jump to File Offset
  - May be good if you find an interesting shellcode or string

Searching
- If it is an unknown password, IDA Pro might be able to help through strings
  - Look in same location that the "invalid key" label is
  - In specific example, stated "push offset aMab ; "$mab"

Using Cross References
- AKA xref can tell you where a function is called or where a string is used
- Data and Code references

Analyzing Functions
- IDA Pro can recognize functions, label them, and break down the local variables and parameters
- Local variables will be at a negative offset relative to EBP and arguments will be at a positive offset
- If labelling is weird, can select BP Based Frame and specifying 4 bytes for Saved Registers

Using Graphing Options
- Honestly, there's about 5 buttons that have descriptions highlighted on page 98-99. Look at those for notes

Enhancing Disassembly
- No undo feature when modifying it's disassembly
- Can rename virtual addresses and stack variables to give them more meaning
  - Can also rename cross-references to understand it a bit better
- : leaves one comment, ; leaves an echo of comments on that cross-reference
- Operands are typically formatted as hex values
- Can also apply named constants on operands
  - Label Windows APIs to make it easier to understand what is going on
  - Need to go to the MSDN page for windows API calls and see the symbolic constants that are associated with each parameter
  - If symbolic constant is not there, can Type Libraries and load them in manually
- Sometimes IDA Pro may label bytes/data wrong (bytes are data/data is bytes)
  - Can be fixed by either manual or by undefining functions, code, or data

Extending IDA with Plug-ins
- IDC and Python are the two most common
- IDC
  - Built-in scripting language that predates Python and Ruby
  - IDC scripts are programs made up of functions, with all functions declared as static
    - Arguments don't need the type specified
    - auto is used to define local variables
- IDAPython
  - Exposes a significant portion of IDA Pro's SDK functionality
  - More powerful scripting than offered with IDC
  - Has 3 modules
    - IDA API (idaapi)
    - IDC Interface (idc)
    - IDAPython (idautils)
  - Programs that use an effective address (EA) to perform the primary method of referencing
  - No abstract data types
  - Most calls take either an EA or a symbol name string
  - Many wrapper functions around the core IDC functions
