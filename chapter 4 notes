\\ assembly, oh boy
\\ Art of Assembly by Randall Hyde
- OS creates a layer of abstraction to communicate with the hardware without it being as complex
- Malware authors create malware using a high-level language
  - uses a compiler to generate it into machine code so the CPU can understand
- Reverse engineers analyze malware using a low-level language
  - uses a decompiler to generate it into machine code to figure out how it operates

Six Levels of Abstraction:
- Hardware
  - The only physical level
    - Consists of electrical circuits that implement complex combinations of logical operations
      - i.e. XOR, AND, OR, NOT gates
        - known as digital logic
  - Most portable level across computer systems
  - Cannot be easily manipulated by software
- Microcode
  - AKA firmware
  - Only operates on the exact circuitry for which it was designed
  - Contains microinstructions that translate from higher machine-code to provide an interface with the hardware
  - Specific to the computer hardware it was written on
- Machine Code
  - Contains opcodes
    - Hexadecimal digits that tell the processor what you want it to do
  - Implemented with severl microcode instructions so that the underlying hardware can execute the code
  - Created when a computer program in a high-level language is compiled
- Low-Level Languages
  - Human-readable version of a computers architecture's instruction set
  - Most common is assembly
  - Use this because machine code is too difficult for a human to comprehend
  - Use a disassembler to generate low-level language
    - Uses mnemonics (i.e. jmp, mov)
  - Dialects of assembly
- High-Level Languages
  - Mostly computer programmers operate at high-level languages
  - Provide strong abstraction from the machine level
  - Make it easy to use programming logic and flow-control mechanisms
  - Includes C, C++
  - Turned into machine code by a compiler through a process called compilation
- Interpreted Languages
  - Top level, which means they are the least portable
  - Includes C#, Perl, .NET, Java
  - Not compiled into machine code, translated into bytecode
    - Bytecode is an intermediate representation that is specific to the programming language
    - Bytecode executes within an interpreter
      - Program that translates bytecode into executable machine code on the fly at runtime
      - Interpreters provide automatic level of abstraction compared to traditionally compiled code
        - Can handle errors and memory management on it's own, independent from the OS

Reverse Engineering
- When malware is stored on a disk, it is in binary form at the machine code level
- Dialects of Assembly include
  - x86, x64, SPARC, PowerPC, MIPS, ARM, etc.
- 32-bit personal computers are x86, AKA Intel IA-32
  - All modern 32-bit versions of Windows are designed to run on x86 architecture
  - Most AMD64 or Intel 64 architectures support x86 32-bit binaries
- Internals of all computers follow the Von Neumann architecture:
  - CPU executes code
  - RAM stores all data and code
  - I/O interfaces with devices (i.e. hard drives, keyboards, monitors, etc.)
- CPU has 3 components:
  - Registers
  - Control Unite
  - ALU (Arithmetic Logic Unit)
- Control unit gets instructions to execute from RAM using the register (the instruction pointer)
  - Stores the address of the instruction to execute
- Registers are the CPU's basic data storage so it doesn't need to access RAM
- ALU executes an instruction fetched from the RAM and places the results in registers or memory

RAM
- RAM can separated in 4 sections:
  - Data (Highest memory address)
    - Contains values that are put in place when a program is initially loaded
    - May be called static values since they typically do not change while the program is running
    - May also be called global values since they are accessible to any part of the program
  - Code
    - Contains the instructions fetched by the CPU to execute the program's tasks
    - Controls what the program does and how the program will be orchestrated
  - Heap
    - Used for dynamic memory during the execution
    - Also used to create/allocate new values
    - And eliminate/free values that the program no longer needs
  - Stack (Lowest memory address)
    - Used for local variables and parameters for functions
    - Also used to help control program flow

Opcodes/Endianness
- Instructions are made of a mnemonic and zero or more operands
  - Mnemonic is a word that identifies the instruction to execute
  - Operands are typically used to identify information used by the instruction (i.e. registers or data)
- Instructions corresponds to opcodes (operation codes)
  - Tells the CPU which operation the program wants to perform
  - Intel defines opcodes more specifically, but basically is machine instruction
- Disassemblers translate opcodes into human-readable instructions
- 0x42000000 is treated as the value 0x42 because the x86 architecture uses little-endian format
  - endianness 
    - describes whether the most significant (big-endian) or least significant (little-endian) byte is ordered first (at the smallest address) within a larger data item
- Malware must change between endianness during network communication
  - Network data uses big-endian
  - x86 program uses little-endian
    - IP address 127.0.0.1 is represented as 0x7F000001 in big-endian (over the network) and 0x01000007F in little endian (locally in memory)

Operands
- Used to identify the data used by an instruction
- 3 types:
  - Immediate operands
    - Fixed values, such as 0x42
  - Register operands
    - Registers, such as ecx/esp
  - Memory address operands
    - Memory address that contains the value of interest
    - Typically denoted by a value, register, or equation between brackets, such as [eax]

Registers
- Small amount of data storage available to the CPU
- Contents can be accessed more quickly than storage elsewhere (i.e. RAM)
- Most common x86 registers:
  - General Registers
    - Used by the CPU during execution
  - Segment Registers
    - Track sections of memory
  - Status Flags
    - Make decisions
  - Instruction Pointers
    - Keep track of the next instruction to execute
- General registers are 32 bits in size
  - Can be referred as 32 or 16 bits in assembly code
  - I.E. EDX is used to reference the full 32-bit register, DX references the lower 16 bits of the EDX register
  - EAX, EBX, ECX, and EDX , CAN be referenced as 8-bit values using the lowest 8 bits/second set of 8 bits
    - AH is used to reference the second set of 8bits, same with AL

General Registers
- Typically store data or memory addresses
- Often used interchangeably to get things accomplished
- Some x86 instructions use specific registers by definition
  - I.E. multiplication and division use EAX and EDX
- Use of registers in a consistent fashion across compiled code is known as a convention
  - Allows malware analysts to analyze faster since time isn't wasted figuring out the context of how a register is used

Flags
- EFLAG register is a status register
  - 32 bits, each bit is a flag
- Each flag is either set (1) or cleared (0) to control CPU operations/indicate the results of a CPU operation
- Most important flags for MA:
  - ZF (Zero Flag)
    - Result as an operation is equal to zero
    - Else it is cleared
  - CF (Carry Flag)
    - Result of an operation is too large/small for the destination operand
    - Otherwise it is cleared
  - SF (Sign Flag)
    - Result when an operation is negative or cleared when the result is positive
    - Also set when most significant bit is set after an arithmetic operation
  - TF (Trap Flag)
    - Used for debugging
    - x86 will execute only one instruction at a time if this flag is set
- EIP
  - AKA Instruction Pointer, Program Counter
  - Register that contains the memory address of the next instruction to be executed
  - Attacks towards this is Buffer Overflow
    - Overwrites the EIP, causes legitimate service to crash and executes code

Simple Instructions
- Most simple/common instruction is mov
  - Moves data from one location to another
    - Can move data into registers or RAM
  - Reads and writes to memory
  - Syntax: mov destination, source
- Can use equation to calculate a memory address
  - Saves space, since it does not rewuire separate instructions to perform the calculation contained in the bracket
    - Make sure it's in the bracket!!
    - i.e. mov eax, [ebx+esi*4]
- A similar instruction is lea
  - Load effective Address
  - syntax: lea destination, source
  - Used to put a memory address into the destination
  - difference: puts source into destination, mov puts the data at the memory address specified by the source
  - Can also be used to calculate values since it requires fewer instructions
    - I.E. lea ebx, [eax*4+4], eax is a number rather than a memory address
      - Equivalent to ebx = (eax+1)*4

Arithmetic
- Can range from basic addition to logical operators
- Addition instruction:
  - add destination, value
- Subtraction instruction:
  - sub destination, value
    - Modifies 2 flags: ZF and CF
      - ZF is set if the result is 0
      - CF is set if the destination is less than the value subtracted
- Also has inc and dec (increments/decrements), same instruction format (just replace add/sub with inc/dec)
- Multiplication and division both act on a predefined register
  - Multiplication format:
    - mul value
  - Division format:
    - div value
  - Can occur anywhere in the code, so look for it
  - mul value instruction always multiplies eax by value
    - Make sure EAX is set up appropiately before multiplication
    - Stored as a 64-bit value across 2 registers: EDX and EAX
      - EDX stores the most significant 32 bits, EAX stores the least significant 32 bits
  - div value does the same thing, but opposite way
    - Divides the 64 bits across EDX and EAX by value
      - EDX and EAX need to be set up appropriately
    - Results are stored in EAX, remainder is stored in EDX
      - Remainder can be obtained by an operation called modulo
        - Compiled into assembly through the use of the EDX register
    - imul and idiv are signed versions of mul and div instructions
- OR, AND, and XOR are logical operatorss that are used in x86 architecture
  - Same format to add and sub
    - I.E. xor eax, eax sets the eax register to zero
      - More optimal, since this only requires 2 bytes, while mov eax, 0 requires 5 bytes
- shr and shl are used to shift registers
  - format:
    - shr destination, count
    - same for shl
  - shr shifts the bits in the destination operand to the right
  - shl shifts the bits in the destination operand to the left
  - Bits shifted beyond the destination boundary are shifted into the CF flag
    - Zero bits are filled in during the shift
- ror and rol are rotation instructions
  - Very siilar to shr and shl, except the bits shifted beyond the destination are rotated to the other end
  - ror is right, rol is left
- Shifting is often used in place of multiplication, since it is simpler and faster than multiplication
  - Shifting 1 bit to the left multiplies by 2, 2 bits multiplies by 4, 3 bits multiplies by 8
- If you see xor, or, and, shl, ror, shr, rol repeatedly, probably is encrypted or compressed
  - Don't worry about it, just move on
- NOP does nothing
  - Pseudonym for xchg eax, eax
  - Opcode is 0x90
  - Used generally when an attacker doesn't have perfect control over their exploitation
    - Provides execution padding, reducing the risk of shellcode executing in the middle causing it to malfunction

The Stack
- Data structure characterized by pushing or popping
- Memory for functions, local variables, and flow control is stores in a stack
- Push on a stack, pop off a stack
  - Last in, first out (LIFO) structure
    - If you push 1, 2, then 3, then 3 will be the first to be popped off since it was the last one to be pushed
  - x86 architecture has built-in support for stack mechanisms
  - Typical registers includes the ESP and EBP registers
  - ESP is the stack pointer
    - Typicall contains a memory address that points to the top of the stack
    - Value typically changes as things are pushed/popped
  - EBP is the base pointer
    - Stays consistent so that the program can use it as a placeholder to keep track of the location of local variables and parameters
- Also includes call, leave, enter, and ret
- Allocated in a top-down format in memory
  - Highest addresses are allocated and used first
    - As values are pushed/popped,s maller addresses are used
- Used for short-term storage only
- Primary use is for management of data exchnaged between function calls
  - Varies among compilers
  - Most common convention is for local variables and parameters to be referenced relative to EBP
- Function calls are portions of code within a program that perform a specific task
  - Relatively independent of the remaining code
  - Main code will call and temporarily transfers execution to functions before returning to the main code
  - Most common convention is cdecl
  - Many functions contain a prologue
    - Few lines of code at the start of a function
    - Prepares the stack and registers for use within the function
  - Many also include an epilogue  
    - Restores the stack and registers to their state before the function was called
  - Common implementation for function calls:
    - 1) Arguments are placed on the stack using push instructions
    - 2) Function is called using memory_location
      - Current instruction address (contents of the EIP register) to be pushed onto the stack
      - Used to return to the main code when function is finished
      - When function begins, EIP is set to memory_location
    - 3) Function prologue allocates space on the stack for local variables and EBP is pushed onto the stack to save EBP for calling the function
    - 4) Function performs its work
    - 5) 
