\\ assembly, oh boy
\\ Art of Assembly by Randall Hyde
- OS creates a layer of abstraction to communicate with the hardware without it being as complex
- Malware authors create malware using a high-level language
  - uses a compiler to generate it into machine code so the CPU can understand
- Reverse engineers analyze malware using a low-level language
  - uses a decompiler to generate it into machine code to figure out how it operates

Six Levels of Abstraction:
- Hardware
  - The only physical level
    - Consists of electrical circuits that implement complex combinations of logical operations
      - i.e. XOR, AND, OR, NOT gates
        - known as digital logic
  - Most portable level across computer systems
  - Cannot be easily manipulated by software
- Microcode
  - AKA firmware
  - Only operates on the exact circuitry for which it was designed
  - Contains microinstructions that translate from higher machine-code to provide an interface with the hardware
  - Specific to the computer hardware it was written on
- Machine Code
  - Contains opcodes
    - Hexadecimal digits that tell the processor what you want it to do
  - Implemented with severl microcode instructions so that the underlying hardware can execute the code
  - Created when a computer program in a high-level language is compiled
- Low-Level Languages
  - Human-readable version of a computers architecture's instruction set
  - Most common is assembly
  - Use this because machine code is too difficult for a human to comprehend
  - Use a disassembler to generate low-level language
    - Uses mnemonics (i.e. jmp, mov)
  - Dialects of assembly
- High-Level Languages
  - Mostly computer programmers operate at high-level languages
  - Provide strong abstraction from the machine level
  - Make it easy to use programming logic and flow-control mechanisms
  - Includes C, C++
  - Turned into machine code by a compiler through a process called compilation
- Interpreted Languages
  - Top level, which means they are the least portable
  - Includes C#, Perl, .NET, Java
  - Not compiled into machine code, translated into bytecode
    - Bytecode is an intermediate representation that is specific to the programming language
    - Bytecode executes within an interpreter
      - Program that translates bytecode into executable machine code on the fly at runtime
      - Interpreters provide automatic level of abstraction compared to traditionally compiled code
        - Can handle errors and memory management on it's own, independent from the OS

Reverse Engineering
- When malware is stored on a disk, it is in binary form at the machine code level
- Dialects of Assembly include
  - x86, x64, SPARC, PowerPC, MIPS, ARM, etc.
- 32-bit personal computers are x86, AKA Intel IA-32
  - All modern 32-bit versions of Windows are designed to run on x86 architecture
  - Most AMD64 or Intel 64 architectures support x86 32-bit binaries
- Internals of all computers follow the Von Neumann architecture:
  - CPU executes code
  - RAM stores all data and code
  - I/O interfaces with devices (i.e. hard drives, keyboards, monitors, etc.)
- CPU has 3 components:
  - Registers
  - Control Unite
  - ALU (Arithmetic Logic Unit)
- Control unit gets instructions to execute from RAM using the register (the instruction pointer)
  - Stores the address of the instruction to execute
- Registers are the CPU's basic data storage so it doesn't need to access RAM
- ALU executes an instruction fetched from the RAM and places the results in registers or memory

RAM
- RAM can separated in 4 sections:
  - Data (Highest memory address)
    - Contains values that are put in place when a program is initially loaded
    - May be called static values since they typically do not change while the program is running
    - May also be called global values since they are accessible to any part of the program
  - Code
    - Contains the instructions fetched by the CPU to execute the program's tasks
    - Controls what the program does and how the program will be orchestrated
  - Heap
    - Used for dynamic memory during the execution
    - Also used to create/allocate new values
    - And eliminate/free values that the program no longer needs
  - Stack (Lowest memory address)
    - Used for local variables and parameters for functions
    - Also used to help control program flow

Opcodes/Endianness
- Instructions are made of a mnemonic and zero or more operands
  - Mnemonic is a word that identifies the instruction to execute
  - Operands are typically used to identify information used by the instruction (i.e. registers or data)
- Instructions corresponds to opcodes (operation codes)
  - Tells the CPU which operation the program wants to perform
  - Intel defines opcodes more specifically, but basically is machine instruction
- Disassemblers translate opcodes into human-readable instructions
- 0x42000000 is treated as the value 0x42 because the x86 architecture uses little-endian format
  - endianness 
    - describes whether the most significant (big-endian) or least significant (little-endian) byte is ordered first (at the smallest address) within a larger data item
- Malware must change between endianness during network communication
  - Network data uses big-endian
  - x86 program uses little-endian
    - IP address 127.0.0.1 is represented as 0x7F000001 in big-endian (over the network) and 0x01000007F in little endian (locally in memory)

Operands
- Used to identify the data used by an instruction
- 3 types:
  - Immediate operands
    - Fixed values, such as 0x42
  - Register operands
    - Registers, such as ecx/esp
  - Memory address operands
    - Memory address that contains the value of interest
    - Typically denoted by a value, register, or equation between brackets, such as [eax]

Registers
- Small amount of data storage available to the CPU
- Contents can be accessed more quickly than storage elsewhere (i.e. RAM)
- Most common x86 registers:
  - General Registers
    - Used by the CPU during execution
  - Segment Registers
    - Track sections of memory
  - Status Flags
    - Make decisions
  - Instruction Pointers
    - Keep track of the next instruction to execute
- General registers are 32 bits in size
  - Can be referred as 32 or 16 bits in assembly code
  - I.E. EDX is used to reference the full 32-bit register, DX references the lower 16 bits of the EDX register
  - EAX, EBX, ECX, and EDX , CAN be referenced as 8-bit values using the lowest 8 bits/second set of 8 bits
    - AH is used to reference the second set of 8bits, same with AL

General Registers
- Typically store data or memory addresses
- Often used interchangeably to get things accomplished
- Some x86 instructions use specific registers by definition
  - I.E. multiplication and division use EAX and EDX
- Use of registers in a consistent fashion across compiled code is known as a convention
  - Allows malware analysts to analyze faster since time isn't wasted figuring out the context of how a register is used

Flags
- EFLAG register is a status register
  - 32 bits, each bit is a flag
- Each flag is either set (1) or cleared (0) to control CPU operations/indicate the results of a CPU operation
- Most important flags for MA:
  - ZF (Zero Flag)
    - Result as an operation is equal to zero
    - Else it is cleared
  - CF (Carry Flag)
    - Result of an operation is too large/small for the destination operand
    - Otherwise it is cleared
  - SF (Sign Flag)
    - Result when an operation is negative or cleared when the result is positive
    - Also set when most significant bit is set after an arithmetic operation
  - TF (Trap Flag)
    - Used for debugging
    - x86 will execute only one instruction at a time if this flag is set
- EIP
  - AKA Instruction Pointer, Program Counter
  - Register that contains the memory address of the next instruction to be executed
  - Attacks towards this is Buffer Overflow
    - Overwrites the EIP, causes legitimate service to crash and executes code

Simple Instructions
- Most simple/common instruction is mov
  - Moves data from one location to another
    - Can move data into registers or RAM
  - Reads and writes to memory
  - Syntax: mov destination, source
- Can use equation to calculate a memory address
  - Saves space, since it does not rewuire separate instructions to perform the calculation contained in the bracket
    - Make sure it's in the bracket!!
    - i.e. mov eax, [ebx+esi*4]
- A similar instruction is lea
  - Load effective Address
  - syntax: lea destination, source
  - Used to put a memory address into the destination
  - difference: puts source into destination, mov puts the data at the memory address specified by the source
  - Can also be used to calculate values since it requires fewer instructions
    - I.E. lea ebx, [eax*4+4], eax is a number rather than a memory address
      - Equivalent to ebx = (eax+1)*4

Arithmetic
- Can range from basic addition to logical operators
- Addition instruction:
  - add destination, value
- Subtraction instruction:
  - sub destination, value
    - Modifies 2 flags: ZF and CF
      - ZF is set if the result is 0
      - CF is set if the destination is less than the value subtracted
- Also has inc and dec (increments/decrements), same instruction format (just replace add/sub with inc/dec)
- Multiplication and division both act on a predefined register
  - Multiplication format:
    - mul value
  - Division format:
    - div value
  - Can occur anywhere in the code, so look for it
  - mul value instruction always multiplies eax by value
    - Make sure EAX is set up appropiately before multiplication
    - Stored as a 64-bit value across 2 registers: EDX and EAX
      - EDX stores the most significant 32 bits, EAX stores the least significant 32 bits
  - div value does the same thing, but opposite way
    - Divides the 64 bits across EDX and EAX by value
      - EDX and EAX need to be set up appropriately
    - Results are stored in EAX, remainder is stored in EDX
      - Remainder can be obtained by an operation called modulo
        - Compiled into assembly through the use of the EDX register
    - imul and idiv are signed versions of mul and div instructions
- OR, AND, and XOR are logical operatorss that are used in x86 architecture
  - Same format to add and sub
    - I.E. xor eax, eax sets the eax register to zero
      - More optimal, since this only requires 2 bytes, while mov eax, 0 requires 5 bytes
- shr and shl are used to shift registers
  - format:
    - shr destination, count
    - same for shl
  - shr shifts the bits in the destination operand to the right
  - shl shifts the bits in the destination operand to the left
  - Bits shifted beyond the destination boundary are shifted into the CF flag
    - Zero bits are filled in during the shift
- ror and rol are rotation instructions
  - Very siilar to shr and shl, except the bits shifted beyond the destination are rotated to the other end
  - ror is right, rol is left
- Shifting is often used in place of multiplication, since it is simpler and faster than multiplication
  - Shifting 1 bit to the left multiplies by 2, 2 bits multiplies by 4, 3 bits multiplies by 8
- If you see xor, or, and, shl, ror, shr, rol repeatedly, probably is encrypted or compressed
  - Don't worry about it, just move on
- NOP does nothing
  - Pseudonym for xchg eax, eax
  - Opcode is 0x90
  - Used generally when an attacker doesn't have perfect control over their exploitation
    - Provides execution padding, reducing the risk of shellcode executing in the middle causing it to malfunction

The Stack
- Data structure characterized by pushing or popping
- Memory for functions, local variables, and flow control is stores in a stack
- Push on a stack, pop off a stack
  - Last in, first out (LIFO) structure
    - If you push 1, 2, then 3, then 3 will be the first to be popped off since it was the last one to be pushed
  - x86 architecture has built-in support for stack mechanisms
  - Typical registers includes the ESP and EBP registers
  - ESP is the stack pointer
    - Typicall contains a memory address that points to the top of the stack
    - Value typically changes as things are pushed/popped
  - EBP is the base pointer
    - Stays consistent so that the program can use it as a placeholder to keep track of the location of local variables and parameters
- Also includes call, leave, enter, and ret
- Allocated in a top-down format in memory
  - Highest addresses are allocated and used first
    - As values are pushed/popped,s maller addresses are used
- Used for short-term storage only
- Primary use is for management of data exchnaged between function calls
  - Varies among compilers
  - Most common convention is for local variables and parameters to be referenced relative to EBP
- Function calls are portions of code within a program that perform a specific task
  - Relatively independent of the remaining code
  - Main code will call and temporarily transfers execution to functions before returning to the main code
  - Most common convention is cdecl
  - Many functions contain a prologue
    - Few lines of code at the start of a function
    - Prepares the stack and registers for use within the function
  - Many also include an epilogue  
    - Restores the stack and registers to their state before the function was called
  - Common implementation for function calls:
    - 1) Arguments are placed on the stack using push instructions
    - 2) Function is called using memory_location
      - Current instruction address (contents of the EIP register) to be pushed onto the stack
      - Used to return to the main code when function is finished
      - When function begins, EIP is set to memory_location
    - 3) Function prologue allocates space on the stack for local variables and EBP is pushed onto the stack to save EBP for calling the function
    - 4) Function performs its work
    - 5) Function epilogue restores the stack
      - ESP is adjusted to free the local variables
      - EBP is restored so that the calling function can properly address it's variables
      - leave instruction sets ESP to equal EBP
        - Pops EBP off the stack
    - 6) Returns by calling the ret instruction
      - Pops the return address off the stack and into EIP
        - Program will continue executing from where the original call was made
    - 7) Stack is adjusted to remove the arguments that were sent (unless they'll be used later)

Stack Layout
- Each time a call is performed, a new stack frame is generated
- Functions maintains its own stack frame until it returns
  - Stack frame is restored and execution is transferred back to the calling function
- Stack is laid out in memory:
  - Lowest memory address -> Current stack frame
  - Next is Caller's stack frame, as it continues to grow, the most recent stack frame has the highest memory address
  - Stack grows up towards 0 from highest to lowest memory address
 - Stack information: 
  - ESP would point at the top of the stack
  - EBP would be set so that the local variables and arguments can be referenced using EBP
- Order of the Stack Frame (highest to lowest):
  - Arguments that are pushed onto the stack before the call are at the bottom of the stack frame
  - Contains the return address that is put on the stack by the call instruction
  - Old EBP is next
    - EBP from the caller's stack frame
- When information is pushed onto the stack, ESP will be decreased
  - Alternatively, if information is popped, ESP will increase
- mov eax, ss:[esp] will directly access the top of the stack without impacting the ESP register
- Convention used depends on the compiler and how the compiler is configured
- pusha and pushad/popa and popad, both push/pop all the registers on/off the stack
  - pusha pushes the 16-bit registers on the stack in the following order:
    - AX, CX, DX, BX, SP, BP, SI, DI
  - pushad pushes the 32-bit registers on the stack in the following order:
    - EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI
  - popad and popa do the same thing in the opposite order, and pops
  - Done to save the current state of the registers to the stack
    - Compilers rarely use these instructions, so if seen means someone hand-coded assembly and/or shellcode

Conditionals
- The ability to make comparisons and make decisions based on the comparisons
- Most popular conditional instructions: test and cmp
  - test instruction is identical to the and instruction
    - Operands involved are not modified by the instruction
    - Only sets the flags
    - ZF typically the flag of interest
      - Test of something against itself is often used to check for NULL values
        - Uses fewer bytes and fewer CPU cycles
  - cmp instruction is identical to the sub instruction
    - Operands involved are not affected
    - Only sets the flags
      - ZF and CF may be changed as a result

Branching
- Branch: sequence of code that is conditionally executed depending on the flow of the program
- Branching: Describes the control flow through the branches of a program
- Most popular instructiong for branching is jmp (jump)
  - Format: jmp location
    - Causes the next instruction executed to be the one specified by the jmp
    - Known as an unconditional jump
  - Won't satisfy all branching needs, since there is no if statement in assembly
- Conditional jumps
  - Use flags to determine whether to jump or to proceed to the next instruction
  - Over 30 types of conditional jumps
  - Most common conditional jump instructions:
    - jz loc
      - Jumps to specified location if ZF = 1
    - jnz loc
      - Jumps to a specified location if ZF = 0
    - je loc
      - Same as jz, but commonly used after a cmp instruction
      - Jumps if destination operand equals the source operand
    - jne loc
      - Same as jnz, but commonly used after a cmp
      - Jumps if destination operand is not equal to the source operand
    - jg loc
      - Performs a signed comparison jump after a cmp
      - Occurs if destination operand is greater than the source operand
    - jge loc
      - Performs signed comparison jump after a cmp
      - Occurs if destination operand is greater than or equal to the source operand
    - ja loc
      - same as jg, but an unsigned comparison is performed
    - jae loc
      - same as jge, but an unsigned comparison is performed
    - jl loc
      - Performs signed comparison jump after a cmp
      - Occurs if the destination operand is less than the source operand
    - jle loc
      - Performs signed comparison jump after a cmp
      - Occurs if the destination operand is less than or equal to the source operand
    - jb loc
      - Same as jl, but an unsigned comparison is performed
    - jbe loc
      - Same as jle, but an unsigned comparison is performed
    - jo loc
      - Jumps if the previous instruction set the OF = 1
    - js loc
      - Jumps if the SF =1
    - jecxz loc
      - Jump to location if ECX = 0

Rep Instructions
- Set of instructions for manupulating data buffers
- Usually in the form of of an array of bytes, but can also be single or double words
  - Intel refers to array of bytes as string instructions
- Most common data buffer manipulation instructions:
  - movsx, cmpsx, stosx, and scasx
    - X in these are replaced with b,w, or d for byte, word, or double word respectively
- ESI, EDI and ECX are used in these operations
  - ESI is the source index register
  - EDI is the destination index register
  - ECX is also used as a counting variable
- Requires a prefix to operate on data lengths greater than 1
  - movsb instruction will move only by a single byte, does not utilize the ECX registerz
- Repeat prefixes are used for multibyte operations
- rep increments the ESI and EDI offsets
  - Decrements the ECX register until ECX = 0
- repe/repz and repne/repnz will continue until ECX = 0 or until the ZF = 1 or 0
- ESI, EDI, and ECX must be probably initialized for rep to be useful
- rep movsb
  - Equivalent to the C memcpy function
  - Copies a sequence of bytes, with the sized defined by ECX
  - Grabs the byte at ESI, stores it at EDI, then increments or decrements the ESI and EDI by 1 according to the settings of the DF (Direction Flag)
    - DF = 0, then increments, else it will decrement
  - Rarely seen in compiled C code, but shellcode is common
    - Sometimes will flip the DF so they can store data in the reverse direction
  - When rep is present, ECX is checked to see if it contains 0
    - If not, it will move the byte from ESI to EDI and decrements ECX until ECX =0
  - ESI must be set to the source buffer address
  - EDI must be set to the destination buffer address
  - ECX must contain the length to copy
- repe cmpsb
  - Equivalent to the C memcmp function
  - Used to compare 2 sequences of bytes to determine whether they contain the same data
  - cmpsb subtracts the value of EDI from the value of ESI, then updates the flags
  - Typically seen with repe
    - When present, compares each byte of the 2 sequences until it finds a difference between the sequences or reaches the end of the comparison
  - cmpsb obtains the ESI, compares the value at EDI to set the flags, then increments the ESI and EDI registers by 1
    - When repe is present, checks ECX and the flags
    - if ECX = 0 or ZF = 0, then operation will stop repeating
  - EDI and ESI must be set to the two buffer locations
  - ECX must be set to the buffer length
  - Continue until ECX = 0 or buffers are not equal
- repne scasb
  - Used to search for a single value in a sequence of bytes
  - AL register defines the value
  - repne compares the byte located at address EDI and AL, rather than ESI
  - Continues until the byte is found or ECX = 0
  - When value is found, ESI stores the location of that value
  - EDI must contain the address of the buffer
  - AL must contain the byte you are looking for
  - ECX must be set to the buffer length
- rep stosb
  - Equivalent to the C memset function
  - Used to store values in a location specified by EDI
  - Same as scasb, except not being searched for, it is just placed in the location
  - rep prefix initializes a buffer of memory
    - Where every byte contains the same value
  - Often seen with xor eax, eax
  - EDI must contain the buffer location
  - AL must contain the initialization value

C Main Method and Offsets
- Malware is often written in C
- Standard C program has 2 arguments for the main method
  - I.E. int main(int argc, char ** argv)
    - argc and argv are determined at runtime
      - argc is an integer that contains the number of arguments 
        - argc is an integer that contains the number of arguments on the command line, including the program name
      - argv is a pointer to an array of strings that contain the command-line arguments
